<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>流浪小猫的博客</title>
  
  <subtitle>记录我的成长点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.xcatliu.com/"/>
  <updated>2020-07-12T12:11:25.000Z</updated>
  <id>http://blog.xcatliu.com/</id>
  
  <author>
    <name>xcatliu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计 pagic.config.ts</title>
    <link href="http://blog.xcatliu.com/2020/07/12/design_pagic_config_ts/"/>
    <id>http://blog.xcatliu.com/2020/07/12/design_pagic_config_ts/</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-07-12T12:11:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名<del>高级 Markdown 工程师</del>资深博客爱好者，我热衷于<del>写博客</del>折腾各种博客系统，写过多个博客主题。</p><p>终于，写主题也无法得到满足，我开始写博客系统了。</p><p>或者说是更广义的，静态网站生成器。</p><p>如今 <a href="https://github.com/xcatliu/pagic" target="_blank" rel="external">Pagic</a> 已经完成了一个雏形，我也邀请了一些朋友试用，经过一些迭代，我决定来重新设计一下 <code>pagic.config.ts</code>，毕竟作为一个静态网站生成器，大部分用户只需要配置一下 <code>pagic.config.ts</code> 就可以构建网站了，所以配置文件的设计是至关重要的。</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE" target="_blank" rel="external">约定优于配置</a></li><li>尽可能语义话，一目了然</li><li>类型统一，不要有选项既能传字符串又能传函数</li><li>参考：<a href="https://deno.land/manual/contributing/style_guide" target="_blank" rel="external">Deno</a>, <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="external">tsconfig.json</a>, <a href="https://webpack.js.org/configuration/" target="_blank" rel="external">webpack</a>, <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="external">Hexo</a>, <a href="https://vuepress.vuejs.org/config/" target="_blank" rel="external">VuePress</a>, <a href="https://gohugo.io/getting-started/configuration/" target="_blank" rel="external">Hugo</a></li></ol><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><h3 id="文件名、目录名"><a href="#文件名、目录名" class="headerlink" title="文件名、目录名"></a>文件名、目录名</h3><p>使用下划线命名法 <code>foo_bar/baz_v2.md</code>。</p><p>依据：<a href="https://deno.land/manual/contributing/style_guide#use-underscores-not-dashes-in-filenames" target="_blank" rel="external">Deno 的建议</a></p><h3 id="变量名、参数名"><a href="#变量名、参数名" class="headerlink" title="变量名、参数名"></a>变量名、参数名</h3><p>使用驼峰命名法 <code>fooBar</code>。</p><p>依据：<a href="https://deno.land/manual/contributing/style_guide#exported-functions-max-2-args-put-the-rest-into-an-options-object" target="_blank" rel="external">Deno 的实际做法</a></p><h3 id="配置文件名称"><a href="#配置文件名称" class="headerlink" title="配置文件名称"></a>配置文件名称</h3><p><code>pagic.config.tsx</code> 或 <code>pagic.config.ts</code>。</p><ul><li>其中 <code>pagic.config.tsx</code> 优先级更高（依据：<a href="https://webpack.js.org/configuration/resolve/#resolveextensions" target="_blank" rel="external">webpack 的默认加载顺序</a>）</li><li>为什么要提供 <code>tsx</code> 和 <code>ts</code> 两种？为什么不统一为 <code>ts</code>？因为一旦使用了 jsx 语法，则必须命名为 <code>tsx</code>，这是 TypeScript 的限制</li><li>为什么不统一为 <code>tsx</code>？因为大部分情况下用 <code>ts</code> 足够了</li><li>只查找当前运行目录下的配置文件，<strong>不提供</strong> <code>--config</code> 的方式指定配置文件（约定优于配置）</li><li>json 格式和 yaml 格式有诸多限制，故使用 ts 来书写配置文件，<strong>不提供</strong>其他选择（约定优于配置）</li><li>其他静态网站生成器的配置文件中，最让人困惑的就是将主题的配置单独抽离出来了，使得我经常需要犹豫，一个配置项到底是属于主配置文件还是属于主题的配置文件。所以，在 Pagic 中只存在一个配置文件</li></ul><p>命名依据：</p><ul><li><code>tsconfig.json</code>（ts）</li><li><code>webpack.config.js</code>（webpack）</li><li><code>.vuepress/config.js</code>（VuePress）</li><li><code>_config.yml</code>（Hexo）</li><li><code>config.json</code>（Hugo）</li></ul><h2 id="文件相关的配置"><a href="#文件相关的配置" class="headerlink" title="文件相关的配置"></a>文件相关的配置</h2><p>文件相关的配置大多参考的 <code>tsconfig.json</code>，因为其最贴合需求——支持指定文件（<code>files</code>）构建。</p><table class="table"><thead><tr><th>配置项</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>srcDir</code></td><td><code>string</code></td><td><code>&#39;.&#39;</code></td><td>构建的源目录。其中的页面都会以相同的目录结构被构建到 <code>outDir</code> 中。默认为当前目录，此时当前目录下的 <code>README.md</code> 会被构建到 <code>${outDir}/index.html</code> 中</td></tr><tr><td><code>outDir</code></td><td><code>string</code></td><td><code>&#39;dist&#39;</code></td><td>构建的目标目录</td></tr><tr><td><code>include</code></td><td><code>glob[]</code></td><td><code>[&#39;**/*&#39;]</code></td><td>在构建的源目录下，所有匹配上 <code>include</code>（并且没有匹配上 <code>exclude</code>）的文件都会被构建。glob 语法<a href="https://github.com/isaacs/minimatch" target="_blank" rel="external">见此</a></td></tr><tr><td><code>exclude</code></td><td><code>glob[]</code></td><td>较长，后续详细介绍</td><td>构建的根目录下，需要排除的文件</td></tr><tr><td><code>files</code></td><td><code>string[]</code></td><td><code>[]</code></td><td>指定文件构建。当传入的是空数组时，会以 <code>include</code> 和 <code>exclude</code> 来匹配；当传入的数组长度大于 0 时，会忽略 <code>include</code> 和 <code>exclude</code>，精确的按照 <code>files</code> 列表来构建</td></tr><tr><td><code>root</code></td><td><code>string</code></td><td><code>&#39;/&#39;</code></td><td>部署站点的基础路径，如果网站部署在一个子路径下，比如 <code>https://xcatliu.github.io/pagic/</code>，那么 <code>root</code> 应该被设置为 <code>&#39;/pagic/&#39;</code></td></tr></tbody></table><h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a><code>exclude</code></h3><p><code>exclude</code> 的默认值较长：</p><pre class=" language-ts"><code class="language-ts"><span class="token punctuation">[</span>  <span class="token comment" spellcheck="true">// Dot files</span>  <span class="token string">'**/.*'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// Node common files</span>  <span class="token string">'**/package.json'</span><span class="token punctuation">,</span>  <span class="token string">'**/package-lock.json'</span><span class="token punctuation">,</span>  <span class="token string">'**/node_modules'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// pagic.config.ts and pagic.config.tsx</span>  <span class="token string">'pagic.config.{ts,tsx}'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// https://docs.npmjs.com/using-npm/developers.html#keeping-files-out-of-your-package</span>  <span class="token string">'**/config.gypi'</span><span class="token punctuation">,</span>  <span class="token string">'**/CVS'</span><span class="token punctuation">,</span>  <span class="token string">'**/npm-debug.log'</span>  <span class="token comment" spellcheck="true">// ${config.outDir} will be added later</span><span class="token punctuation">]</span></code></pre><p>注意这里的每一项都可以匹配到文件或目录，以 <code>**/node_modules</code> 为例，它：</p><ul><li>不仅能匹配到 <code>${srcDir}</code> 下的 <code>node_modules</code> 目录（以及此目录下的所有文件）</li><li>也能匹配到 <code>${srcDir}</code> 下的 <code>node_modules</code> 文件</li><li>当然也能匹配到 <code>${srcDir}</code> 下的任意多级子目录下的 <code>node_modules</code> 目录或文件</li></ul><p>实际上，<code>**/node_modules</code> 会被转化为 <code>**/node_modules{,/**}</code>，这样就能匹配到以上所有情况了。</p><p>需要注意的是：</p><ul><li>匹配时以 <code>srcDir</code> 为根目录开始匹配。比如 <code>pagic.config.{ts,tsx}</code> 就只能匹配到 <code>srcDir</code> 下的文件，而不能匹配到 <code>srcDir</code> 的子目录下的文件，若要匹配上子目录，需要加上前缀 <code>*/</code>，若要匹配上任意多级子目录，需要加上前缀 <code>**/</code></li><li><code>include</code> 的匹配策略和 <code>exclude</code> 一致</li><li><code>files</code> 是精确匹配，且只匹配文件，不匹配目录</li><li>用户配置的 <code>include</code> 和 <code>exclude</code> 会 append 到默认值数组中，而不是替换它</li></ul><p>通过这些配置，Pagic 可以灵活的运用于各种场景：</p><h3 id="场景一：纯网站，独立的目录存放源文件"><a href="#场景一：纯网站，独立的目录存放源文件" class="headerlink" title="场景一：纯网站，独立的目录存放源文件"></a>场景一：纯网站，独立的目录存放源文件</h3><p>如果仅仅是想搭建一个网站，那么最方便的方式是使用这样的目录结构，将源文件与构建好的文件分开：</p><pre class=" language-bash"><code class="language-bash">website/├── dist/<span class="token operator">|</span>   └── index.html├── src/<span class="token operator">|</span>   ├── _layout.tsx<span class="token operator">|</span>   └── README.md└── pagic.config.ts</code></pre><p>此时 <code>pagic.config.ts</code> 的配置很简单：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  srcDir<span class="token punctuation">:</span> <span class="token string">'src'</span><span class="token punctuation">,</span>  outDir<span class="token punctuation">:</span> <span class="token string">'dist'</span><span class="token punctuation">}</span></code></pre><h3 id="场景二：纯网站，根目录存放源文件"><a href="#场景二：纯网站，根目录存放源文件" class="headerlink" title="场景二：纯网站，根目录存放源文件"></a>场景二：纯网站，根目录存放源文件</h3><p>项目的根目录下一般都有个 <code>README.md</code>，有时我们希望这个文件也被构建为一个页面，此时我们可以将 <code>srcDir</code> 设置为 <code>&#39;.&#39;</code>，比如参考 GitBook 的目录结构组织的话，就是这样的：</p><pre class=" language-bash"><code class="language-bash">book/├── dist/<span class="token operator">|</span>   ├── basics/<span class="token operator">|</span>   <span class="token operator">|</span>   └── index.html<span class="token operator">|</span>   ├── advenced/<span class="token operator">|</span>   <span class="token operator">|</span>   └── index.html<span class="token operator">|</span>   └── index.html├── basics/<span class="token operator">|</span>   └── README.md├── advenced/<span class="token operator">|</span>   └── README.md├── _layout.tsx├── README.md└── pagic.config.ts</code></pre><p>此时 <code>pagic.config.ts</code> 的配置也很简单：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  srcDir<span class="token punctuation">:</span> <span class="token string">'.'</span><span class="token punctuation">,</span>  outDir<span class="token punctuation">:</span> <span class="token string">'dist'</span><span class="token punctuation">}</span></code></pre><p>注意如果有需要排除的文件，可以使用 <code>exclude</code> 排除掉，比如：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  srcDir<span class="token punctuation">:</span> <span class="token string">'.'</span><span class="token punctuation">,</span>  outDir<span class="token punctuation">:</span> <span class="token string">'dist'</span><span class="token punctuation">,</span>  exclude<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'examples'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="场景三：项目-网站"><a href="#场景三：项目-网站" class="headerlink" title="场景三：项目 + 网站"></a>场景三：项目 + 网站</h3><p>如果是在一个项目中要搭建网站，又不想重新建一个仓库，那么前两种方式都可以满足需求：</p><ol><li>网站源文件放到 <code>docs</code> 目录下，<code>srcDir</code> 配置为 <code>&#39;docs&#39;</code> 即可。优点是配置简单，不用配置 <code>include</code> 和 <code>exclude</code></li><li>直接在根目录下构建网站，<code>srcDir</code> 配置为 <code>&#39;.&#39;</code>，再配置 <code>include</code> 包含网站的存放目录即可。优点是包含了根目录下的 <code>README.md</code></li></ol><h3 id="场景四：仅展示-README-md"><a href="#场景四：仅展示-README-md" class="headerlink" title="场景四：仅展示 README.md"></a>场景四：仅展示 README.md</h3><p>有的项目很简单，只需要一个 <code>README.md</code> 即可，不需要其他页面了，此时可以配置 <code>files</code> 仅包含 <code>README.md</code>：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  srcDir<span class="token punctuation">:</span> <span class="token string">'.'</span><span class="token punctuation">,</span>  outDir<span class="token punctuation">:</span> <span class="token string">'dist'</span><span class="token punctuation">,</span>  files<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'README.md'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>插件是 Pagic 中最核心的功能，Pagic 甚至将最基本的构建流程也拆分为了插件——内置插件。插件分为三种：</p><ol><li>内置插件：最基本的构建流程，一定会运行</li><li>官方插件：由 Pagic 实现的插件，可选，如：<code>sidebar</code>，<code>ga</code> 等</li><li>第三方插件：由第三方实现的插件，可选。遵循 Deno 的设计，入口为一个 url，如：<code>https://github.com/xcatliu/pagic_plugin_example/blob/master/mod.ts</code></li></ol><table class="table"><thead><tr><th>配置项</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>plugins</code></td><td><code>string[]</code></td><td><code>[&#39;init&#39;, &#39;md&#39;, &#39;tsx&#39;, &#39;script&#39;, &#39;layout&#39;, &#39;write&#39;]</code></td><td>插件列表，内置插件和官方插件的取值均为插件名，第三方插件的取值为其入口 url</td></tr></tbody></table><p>插件执行的顺序按照其配置顺序，除非该插件在实现时配置了一个 <code>insert</code> 属性：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'customPlugin'</span><span class="token punctuation">,</span>  insert<span class="token punctuation">:</span> <span class="token string">'before:script'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// fn 的设计参考了 Deno https://deno.land/manual/testing#writing-tests</span>  fn<span class="token punctuation">:</span> <span class="token punctuation">(</span>pagic<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// balabala</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>name</code> 是插件的唯一标识，会被用于 <code>insert</code> 中的插件排序。</p><p><code>insert</code> 的语法是 <code>before:${pluginName}</code> 或 <code>after:${pluginName}</code>。这种方式比其他静态网站生成器中需要注册各种各样的生命周期钩子更方便也更灵活。</p><p><code>fn</code> 是一个函数，仅接受一个参数，<code>pagic</code> 实例，它可以访问到 Pagic 在运行中的所有配置、上下文。如果插件需要一些额外的配置，可以约定在 <code>pagic.config.ts</code> 中新增一条配置项 <code>customPlugin</code>，然后在 <code>fn</code> 中可以通过 <code>pagic.config.customPlugin</code> 获取到配置。</p><p>需要注意的是：</p><ul><li>用户配置的 <code>plugins</code> 会 append 到默认数组中，而不是替换它</li><li>插件在运行时会根据其 <code>insert</code> 排序再运行</li><li>可以使用 <code>-</code> 前缀删除掉某个内置插件，这个特性不常用，只有在以下两种情况下需要使用：<ol><li>仅仅将 React 作为一个模版引擎，想构建出不加载 React 的 html 页面时，可以使用 <code>-script</code> 去掉构建 js 脚本的插件，注意此时 React 中的脚本比如 <code>useState</code> 就不会在客户端执行了</li><li>想要自己替换掉一些内置插件，比如使用 <code>-md</code> 去掉解析 markdown 文件的插件，然后再添加一个自定义插件 <code>https://github.com/xcatliu/pagic_plugin_custom_md/blob/master/mod.ts</code> 这样可以修改 Pagic 核心的构建流程，实现更高自由度的个性化</li></ol></li><li>第三方插件一般都需要 <code>insert</code> 属性，不然就会在 <code>write</code> 之后运行了，很少有插件需要在构建完成写入文件后再执行</li></ul><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>主题是 Pagic 中的核心功能之一，有官方主题和第三方主题两种</p><table class="table"><thead><tr><th>配置项</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>theme</code></td><td><code>string</code></td><td><code>default</code></td><td>官方主题的取值为主题名，第三方插件的取值为其入口 url</td></tr></tbody></table><p>主题的运行机制很容易理解——当运行 <code>pagic build</code> 时，会将主题中的所有文件都“复制”到 <code>srcDir</code> 下，然后按照正常的模式运行 <code>build</code>。</p><p>当然，这个“复制”并不会真的复制文件。而且遇到冲突的文件时，也是以用户的文件为准。</p><p>为什么主题需要一个入口文件呢？</p><p>因为 Deno 的设计中，模块调用是以 url 为基础的，想象一个网址表示一个主题，我们没有办法像 node 一样用 <code>fs.readdir</code> 来找到此主题目录下的所有文件，所以必须有一个入口文件来表示此主题包含了哪些文件：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token keyword">extends</span><span class="token punctuation">:</span> <span class="token string">'default'</span><span class="token punctuation">,</span>  files<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token string">'assets/index.css'</span><span class="token punctuation">,</span>    <span class="token string">'assets/reset.css'</span><span class="token punctuation">,</span>    <span class="token string">'assets/variables.css'</span><span class="token punctuation">,</span>    <span class="token string">'_layout.tsx'</span><span class="token punctuation">,</span>    <span class="token string">'favicon.ico'</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>其中 <code>files</code> 表示需要被“复制”到 <code>srcDir</code> 下的文件。</p><p>另外还支持使用 <code>extends</code> 来继承一个主题，官方主题的取值为主题名，第三方插件的取值为其入口 url。它常用于想基于某个主题自定义样式，创建一个新主题。比如官方的 <code>docs</code> 主题以及很完善了，那么可以继承后覆盖掉其 <code>assets/variables.css</code> 文件，创建一个新样式的主题。</p><h2 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h2><p>这里列出一些约定好的配置，它们通常由插件或主题来实现。</p><table class="table"><thead><tr><th>配置项</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td><code>string</code></td><td><code>&#39;&#39;</code></td><td>网站标题，通常会放到页面的标题后面，如：<code>函数的类型 · TypeScript 入门教程</code>，若该页面不存在页面标题，则只会展示网站标题 <code>TypeScript 入门教程</code></td></tr><tr><td><code>description</code></td><td><code>string</code></td><td><code>&#39;&#39;</code></td><td>网站描述，通常会放到 <code>&lt;head&gt;&lt;meta name=&quot;description&quot;&gt;</code> 中展示，也有可能展示在页面中</td></tr><tr><td><code>head</code></td><td><code>React.ReactNode</code></td><td><code>undefined</code></td><td>额外被注入到 <code>&lt;head&gt;</code> 中的内容，可以写 jsx。注意此时需要将配置文件改为 <code>tsx</code> 后缀 <code>pagic.config.tsx</code></td></tr><tr><td><code>sidebar</code></td><td></td><td><code>undefined</code></td><td>侧边栏</td></tr><tr><td><code>nav</code></td><td></td><td><code>undefined</code></td><td>顶部导航</td></tr><tr><td><code>github</code></td><td><code>string</code></td><td><code>undefined</code></td><td>网站的 GitHub 地址，通常会展示在网页的右上角</td></tr><tr><td><code>ga</code></td><td></td><td><code>undefined</code></td><td>Google Analytics 配置</td></tr><tr><td><code>gitalk</code></td><td></td><td><code>undefined</code></td><td>Gitalk 配置</td></tr><tr><td><code>tocAd</code></td><td><code>React.ReactNode</code></td><td><code>undefined</code></td><td>展示在 toc 上方的广告</td></tr><tr><td><code>tools</code></td><td></td><td><code>undefined</code></td><td>一些额外的功能</td></tr></tbody></table><h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><table class="table"><thead><tr><th>配置项</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>watch</code></td><td><code>boolean</code></td><td><code>false</code></td><td>是否观察 <code>srcDir</code> 目录，有变化后重新构建</td></tr><tr><td><code>serve</code></td><td><code>boolean</code></td><td><code>false</code></td><td>是否启动一个静态服务</td></tr><tr><td><code>port</code></td><td><code>number</code></td><td><code>8000</code></td><td>静态服务端口号</td></tr></tbody></table><hr><p>本文会持续更新，直到 Pagic 1.0 发布。</p>]]></content>
    
    <summary type="html">
    
      Pagic 是一个静态网站生成器，使用 Deno 和 React 开发。本文介绍其配置文件 pagic.config.ts 的设计。
    
    </summary>
    
      <category term="Programmer" scheme="http://blog.xcatliu.com/categories/Programmer/"/>
    
    
      <category term="Pagic" scheme="http://blog.xcatliu.com/tags/Pagic/"/>
    
  </entry>
  
  <entry>
    <title>测试的分类</title>
    <link href="http://blog.xcatliu.com/2019/03/11/types_of_tests/"/>
    <id>http://blog.xcatliu.com/2019/03/11/types_of_tests/</id>
    <published>2019-03-10T16:00:00.000Z</published>
    <updated>2019-03-11T04:48:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，我都听到过各式各样的测试——单元测试、黑盒测试、压力测试等等，但是很难对所有的测试方式有一个总体的认知。</p><p>在经过大量的谷歌之后，我终于把各种种类的测试弄清白了，下面针对每一种测试做一个简单的一句话介绍，更详细的介绍可以自行搜索。</p><a id="more"></a><h2 id="按测试阶段分类"><a href="#按测试阶段分类" class="headerlink" title="按测试阶段分类"></a>按测试阶段分类</h2><ul><li>单元测试：针对单个函数、类进行测试</li><li>集成测试：将各单元组合之后进行测试，用来验证各个组件之间能否互相配合，正常工作</li><li>系统测试：针对整个系统进行全面的测试，涵盖功能和非功能（兼容性、性能等）方面<ul><li>端到端测试：与系统测试类似，模仿完全真实的用户环境，如网络通信、数据库交互等，也会验证其他关联系统。通常会手动测试，很难自动化</li></ul></li><li>验收测试：验证交付的产品是否符合预期的各项要求，测试内容通常是系统测试的子集<ul><li>alpha 测试：验收测试的一种，由内部用户在测试环境进行测试</li><li>beta 测试：验收测试的一种，由外部用户在正式环境下进行测试</li></ul></li></ul><h2 id="是否查看源代码"><a href="#是否查看源代码" class="headerlink" title="是否查看源代码"></a>是否查看源代码</h2><ul><li>黑盒测试：不关心内部细节，只要输入和输出符合要求即可</li><li>白盒测试：验证代码中的每条语句，每个分支都能正确运行<ul><li>分支测试：白盒测试的一种，在单元测试期间进行，通过遍历每个分支进行彻底的测试</li></ul></li><li>灰盒测试：既考虑产品设计要求，又考虑代码的实现细节</li></ul><h2 id="是否运行程序"><a href="#是否运行程序" class="headerlink" title="是否运行程序"></a>是否运行程序</h2><ul><li>静态测试：不运行程序，仅通过语法分析来检查程序的正确性。代表：ESLint</li><li>动态测试：通过运行程序，检查运行结果与预期结果的差异</li></ul><h2 id="是否验证产品功能"><a href="#是否验证产品功能" class="headerlink" title="是否验证产品功能"></a>是否验证产品功能</h2><ul><li>功能测试：验证产品功能是否符合预期</li><li>非功能测试：可用性、兼容性、性能、负载、压力、可伸缩性、安全性等<ul><li>可用性测试：验证新用户是否可以轻松理解如何使用产品</li><li>可访问性测试：残疾人能否正常使用产品</li><li>兼容性测试：验证在不同版本的终端上是否能正确运行</li><li>边界值测试：检查输入为边界值时程序能否正确运行</li><li>负载测试：考察当前软硬件环境下系统所能承受的最大负荷</li><li>压力测试：在一定的负载下系统长时间运行的稳定性</li><li>性能测试：检查系统是否满足性能要求</li><li>体积测试：当遇到大量数据时是否会影响系统性能</li><li>安全测试：检查系统是否存在安全漏洞</li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>猴子测试：无需理解程序，由随机的输入进行测试</li><li>突变测试：修改一小段源代码，验证现有测试用例能否识别此缺陷</li><li>恢复测试：验证系统能否从灾难（断电、断网等）中恢复</li><li>冒烟测试：对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性</li><li>回归测试：验证代码更改是否不会影响产品的现有功能</li></ul><p>还有很多种测试，由于比较偏门所以我没有列出来。</p><p>我参考了大量<a href="https://www.softwaretestinghelp.com/types-of-software-testing/" target="_blank" rel="external">这个网站</a>的内容，感兴趣的可以看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来，我都听到过各式各样的测试——单元测试、黑盒测试、压力测试等等，但是很难对所有的测试方式有一个总体的认知。&lt;/p&gt;
&lt;p&gt;在经过大量的谷歌之后，我终于把各种种类的测试弄清白了，下面针对每一种测试做一个简单的一句话介绍，更详细的介绍可以自行搜索。&lt;/p&gt;
    
    </summary>
    
      <category term="Programmer" scheme="http://blog.xcatliu.com/categories/Programmer/"/>
    
    
      <category term="Testing" scheme="http://blog.xcatliu.com/tags/Testing/"/>
    
  </entry>
  
  <entry>
    <title>Puppeteer 指南</title>
    <link href="http://blog.xcatliu.com/2018/09/18/puppeteer_tutorial/"/>
    <id>http://blog.xcatliu.com/2018/09/18/puppeteer_tutorial/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2018-10-08T08:28:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Puppeteer 是 Google Chrome 出品的一个无头浏览器。如果你听说过 Phantomjs 或者 Selenium，那么就应该知道它是做什么的了。Puppeteer 与它们类似，提供了一系列 api，通过 DevTools 协议控制 Chromium/Chrome 浏览器的行为。</p><h2 id="什么是无头浏览器"><a href="#什么是无头浏览器" class="headerlink" title="什么是无头浏览器"></a>什么是无头浏览器</h2><p>无头浏览器就是没有用户界面的浏览器，即通过写脚本来使用无头浏览器访问网站，还可以做一些点击等行为。</p><p>Puppeteer 一般使用无头的模式运行，这样的开销较小。当然也提供了使用完整的 Chromium/Chrome 来运行的模式。</p><h2 id="Puppeteer-能做什么"><a href="#Puppeteer-能做什么" class="headerlink" title="Puppeteer 能做什么"></a>Puppeteer 能做什么</h2><p>能够做几乎所有浏览器能做的事情。</p><ul><li>网页截图，或生成 pdf</li><li>爬取 SPA 或 SSR 网站</li><li>自动化表单提交，UI测试，键盘输入等</li><li>创建一个最新的自动化测试环境。使用最新的 js 和最新的 Chrome 浏览器运行测试用例</li><li>捕获网站的时间线，帮助诊断性能问题</li><li>测试 Chrome 插件</li></ul><h2 id="Puppeteer-与其他无头浏览器有什么区别？"><a href="#Puppeteer-与其他无头浏览器有什么区别？" class="headerlink" title="Puppeteer 与其他无头浏览器有什么区别？"></a>Puppeteer 与其他无头浏览器有什么区别？</h2><ul><li>Puppeteer 由 Google Chrome 维护，速度快、安全、稳定、易用</li><li>其他无头浏览器可以支持多种浏览器环境（Safari, Chrome, Firefox 等），而 Puppeteer 只支持 Chromium/Chrome</li><li>Puppeteer 有完善的事件系统，不需要频繁的 <code>sleep(1000)</code> 了</li><li>Puppeteer 的调试功能很强大，还支持在 DevTools 里面调试</li><li>Puppeteer 能够创建一个「真实」的行为，如点击</li></ul><h2 id="安装-Puppeteer"><a href="#安装-Puppeteer" class="headerlink" title="安装 Puppeteer"></a>安装 Puppeteer</h2><p>先创建一个测试用的项目，执行 <code>npm init</code> 初始化好 <code>package.json</code>，然后执行以下命令安装 Puppeteer：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> puppeteer --save-dev</code></pre><p>万事开头难，第一步安装时就会遇到问题（如果没有报错，请跳过这一段）。</p><p>Puppeteer 安装过程中会去下载 Chromium，墙内用户则会报错。如果你看到以下信息，说明是下载 Chromium 时连接不上。</p><pre class=" language-bash"><code class="language-bash">ERROR: Failed to download Chromium r588429<span class="token operator">!</span> Set <span class="token string">"PUPPETEER_SKIP_CHROMIUM_DOWNLOAD"</span> <span class="token function">env</span> variable to skip download.Error: Download failed: server returned code 502. URL: https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/588429/chrome-win32.zip</code></pre><p>或者</p><pre class=" language-bash"><code class="language-bash">ERROR: Failed to download Chromium r588429<span class="token operator">!</span> Set <span class="token string">"PUPPETEER_SKIP_CHROMIUM_DOWNLOAD"</span> <span class="token function">env</span> variable to skip download.<span class="token punctuation">{</span> Error: connect ETIMEDOUT 172.217.24.48:443</code></pre><p>如提示所说，设置 <code>PUPPETEER_SKIP_CHROMIUM_DOWNLOAD</code> 可以跳过安装 Chromium。</p><pre class=" language-bash"><code class="language-bash">PUPPETEER_SKIP_CHROMIUM_DOWNLOAD<span class="token operator">=</span>1 <span class="token function">npm</span> <span class="token function">install</span> puppeteer --save-dev</code></pre><p>此时可以安装成功，但是使用 Puppeteer 时会由于找不到 Chromium 而报错。可以创建一个文件 <code>test.js</code>，内容如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> puppeteer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'puppeteer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> browser <span class="token operator">=</span> <span class="token keyword">await</span> puppeteer<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> page <span class="token operator">=</span> <span class="token keyword">await</span> browser<span class="token punctuation">.</span><span class="token function">newPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">await</span> page<span class="token punctuation">.</span><span class="token function">goto</span><span class="token punctuation">(</span><span class="token string">'https://example.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">await</span> page<span class="token punctuation">.</span><span class="token function">screenshot</span><span class="token punctuation">(</span><span class="token punctuation">{</span>path<span class="token punctuation">:</span> <span class="token string">'example.png'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">await</span> browser<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>然后执行 <code>node test.js</code> 则会报错：</p><pre class=" language-bash"><code class="language-bash">$ node test.js<span class="token punctuation">(</span>node:18368<span class="token punctuation">)</span> UnhandledPromiseRejectionWarning: Unhandled promise rejection <span class="token punctuation">(</span>rejection id: 1<span class="token punctuation">)</span>: Error: Chromium revision is not downloaded. Run <span class="token string">"npm install"</span> or <span class="token string">"yarn install"</span><span class="token punctuation">(</span>node:18368<span class="token punctuation">)</span> <span class="token punctuation">[</span>DEP0018<span class="token punctuation">]</span> DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero <span class="token keyword">exit</span> code.</code></pre><p>一个解决方案是先手动下载 Chromium，然后在执行时通过配置指定 Chromium 位置，<a href="https://juejin.im/post/5b4a043751882519790c7ad7" target="_blank" rel="external">这篇文章</a>给出了解决步骤。</p><p>但是我更倾向于还原 Puppeteer 安装时的过程。但是由于一些环境原因，即便翻墙了也只能手动下载 Chromium，无法在安装 Puppeteer 时自动下载 Chromium。</p><p>读了一下源码之后，可以这么解决：</p><ol><li>安装 Puppeteer，安装失败，提示无法下载 <code>https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/588429/chrome-win32.zip</code></li><li>使用 <code>PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1 npm install puppeteer --save-dev</code> 成功安装 Puppeteer</li><li>执行 <code>node test.js</code> 提示无法找到 Chromium</li><li>手动下载步骤 1 中的 <code>chrome-win32.zip</code>，注意不同版本、不同系统的下载地址是不一样的</li><li>开启一个静态文件服务，使得 <code>http://127.0.0.1:8000/chrome-win32.zip</code> 指向需要下载的文件</li><li>改写 <code>downloadURL</code> 方法，使其直接返回 <code>http://127.0.0.1:8000/chrome-win32.zip</code></li><li>执行 <code>node ./node_modules/puppeteer/install.js</code> 完成安装</li><li>执行 <code>node test.js</code> 测试能否成功生成截图</li></ol><p>至此，成功完成了 Puppeteer 的安装。</p><h2 id="Puppeteer-结构"><a href="#Puppeteer-结构" class="headerlink" title="Puppeteer 结构"></a>Puppeteer 结构</h2><p>Puppeteer 通过 DevTools 协议控制 Chromium/Chrome 浏览器。它的结构和浏览器结构类似。</p><blockquote><p>下图中淡化显示的可以忽略</p></blockquote><p><img src="/assets/puppeteer_turorial/puppeteer-structure.png" alt="Puppeteer 结构"></p><ul><li>Puppeteer 通过 DevTools 协议控制 Chromium/Chrome 浏览器</li><li>一个浏览器（Browser）实例可以包含多个浏览器上下文（Browser contexts），就像我们打开一个普通的 Chrome 之后又打开一个隐身模式的 Chrome</li><li>一个浏览器上下文（BrowserContext）可以包含多个页面（Pages）</li><li>一个页面（Page）包含至少一个主 frame，也可以包含其他 frames（在主 frame 中通过 iframe 或 frame 标签创建的）</li><li>一个 frame 包含至少一个执行上下文（Execution context），也可以包含其他执行上下文（由 Chrome 插件创建的）</li><li>一个 Workder 包含一个执行上下文，由 WebWorker 创建</li></ul><h2 id="Puppeteer-API"><a href="#Puppeteer-API" class="headerlink" title="Puppeteer API"></a>Puppeteer API</h2><p>Puppeteer 的大部分 API 的返回值都是 <code>Promise</code>，故推荐使用 <code>async</code> <code>await</code> 来处理异步操作。Puppeteer 的 API 包含以下类：</p><table class="table"><thead><tr><th>类名</th><th>描述</th></tr></thead><tbody><tr><td><code>Puppeteer</code></td><td>主要用于创建一个浏览器实例，也可以用来下载新的 Chromium，或者设置浏览器的默认参数</td></tr><tr><td><code>BrowserFetcher</code></td><td>用于下载和管理 Chromium</td></tr><tr><td><code>Browser</code></td><td>可以创建一个或多个 Page</td></tr><tr><td><code>BrowserContext</code></td><td>创建一个隐身模式的浏览器时需要用到</td></tr><tr><td><code>Page</code></td><td><strong>主要 API，用于操作一个页面，后面会详细介绍</strong></td></tr><tr><td><code>Worker</code></td><td>用于处理 WebWorker</td></tr><tr><td><code>Keyboard</code></td><td>可以触发键盘按键</td></tr><tr><td><code>Mouse</code></td><td>可以触发鼠标动作</td></tr><tr><td><code>TouchScreen</code></td><td>可以触发触摸屏的动作</td></tr><tr><td><code>Tracing</code></td><td>用于分析性能</td></tr><tr><td><code>Dialog</code></td><td>存在于 page 的 <code>dialog</code> 事件回调中，表示调用弹窗后的对象，包括 <code>alert</code>, <code>beforeunload</code>, <code>confirm</code> 和 <code>prompt</code></td></tr><tr><td><code>ConsoleMessage</code></td><td>存在于 page 的 <code>console</code> 事件回调中，表示调用 <code>console.log</code> 等方法后的对象</td></tr><tr><td><code>Frame</code></td><td>常用于处理包含多个 frame 的页面。page 中的很多方法就是直接调用的主 frame 的方法</td></tr><tr><td><code>ExecutionContext</code></td><td>执行上下文存在于 frame、浏览器插件、worker 中。可以用来直接执行一段 js</td></tr><tr><td><code>JSHandle</code></td><td>通过 <code>page.evaluateHandle</code> 生成，用于将页面中的 handler 挑出来传递使用</td></tr><tr><td><code>ElementHandle</code></td><td>通过 <code>page.$</code> 生成，用于将页面中某个元素的 handler 挑出来传递使用</td></tr><tr><td><code>Request</code></td><td>在 <code>page.setRequestInterception</code> 方法中使用，可以处理页面的请求</td></tr><tr><td><code>Response</code></td><td>表示页面接收到的响应</td></tr><tr><td><code>SecurityDetails</code></td><td>表示页面的安全信息</td></tr><tr><td><code>Target</code></td><td>可以是 page, background_page, service_worker, browser 等</td></tr><tr><td><code>CDPSession</code></td><td>用于直接和 Devtools 通信</td></tr><tr><td><code>Coverage</code></td><td>用于分析 js 和 css 的代码被页面使用的比例</td></tr><tr><td><code>TimeoutError</code></td><td>超时错误</td></tr></tbody></table><h3 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h3><p>Page 是 Puppeteer 中最重要的一个 API，也是它的核心所在，这里会介绍一些常用的 Page API。</p><h4 id="设置页面环境"><a href="#设置页面环境" class="headerlink" title="设置页面环境"></a>设置页面环境</h4><table class="table"><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>page.emulate</code></td><td>设置 viewport 和 ua</td></tr><tr><td><code>page.setViewport</code></td><td>设置 viewport</td></tr><tr><td><code>page.setUserAgent</code></td><td>设置 ua</td></tr><tr><td><code>page.setRequestInterception</code></td><td><strong>中断所有请求，并可以修改请求的返回值</strong></td></tr><tr><td><code>page.addScriptTag</code></td><td>添加 js 脚本</td></tr><tr><td><code>page.addStyleTag</code></td><td>添加 css</td></tr><tr><td><code>page.setContent</code></td><td>设置整个 html</td></tr><tr><td><code>page.setCacheEnabled</code></td><td>设置缓存是否开启</td></tr><tr><td><code>page.setExtraHTTPHeaders</code></td><td>设置额外的 http 头</td></tr><tr><td><code>page.setGeolocation</code></td><td>设置地理位置</td></tr><tr><td><code>page.setJavaScriptEnabled</code></td><td>设置 js 是否开启</td></tr><tr><td><code>page.setOfflineMode</code></td><td>设置离线模式</td></tr><tr><td><code>page.deleteCookie</code></td><td>删除 cookies</td></tr><tr><td><code>page.setCookie</code></td><td>设置 cookies</td></tr></tbody></table><h4 id="模拟动作"><a href="#模拟动作" class="headerlink" title="模拟动作"></a>模拟动作</h4><p>一般会先滚动视窗到相应元素那，再执行动作。</p><table class="table"><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>page.click</code></td><td>点击</td></tr><tr><td><code>page.tap</code></td><td>手指点击</td></tr><tr><td><code>page.focus</code></td><td>聚焦</td></tr><tr><td><code>page.hover</code></td><td>hover</td></tr><tr><td><code>page.type</code></td><td>在指定元素中输入内容</td></tr><tr><td><code>page.select</code></td><td>选中 <code>&lt;select&gt;</code> 的某个选项</td></tr></tbody></table><h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><table class="table"><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>page.waitFor</code></td><td>等待某个元素渲染出来，或者某个函数执行之后返回 <code>true</code>，或者直接等待指定的时间</td></tr><tr><td><code>page.waitForSelector</code></td><td>等待某个元素被渲染</td></tr><tr><td><code>page.waitForFunction</code></td><td>等待某个函数执行之后返回 <code>true</code></td></tr><tr><td><code>page.waitForNavigation</code></td><td>等待页面跳转</td></tr><tr><td><code>page.waitForRequest</code></td><td>等待某个特定的请求被发出</td></tr><tr><td><code>page.waitForResponse</code></td><td>等待某个特定的请求收到了回应</td></tr></tbody></table><h4 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h4><table class="table"><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>page.$</code></td><td>使用 <code>document.querySelector</code> 获取结果，会返回 <code>ElementHandle</code>，可以传递使用</td></tr><tr><td><code>page.$$</code></td><td>同上，不过使用的是 <code>document.querySelectorAll</code></td></tr><tr><td><code>page.$eval</code></td><td>将 <code>document.querySelector</code> 获取的结果传递给 <code>pageFunction</code></td></tr><tr><td><code>page.$$eval</code></td><td>同上，不过使用的是 <code>document.querySelectorAll</code></td></tr><tr><td><code>page.evaluate</code></td><td>直接执行脚本</td></tr><tr><td><code>page.evaluateHandle</code></td><td>执行脚本，返回的是 <code>JSHandle</code>，可以传递使用</td></tr><tr><td><code>page.evaluateOnNewDocument</code></td><td>在下个 frame 执行脚本</td></tr><tr><td><code>page.exposeFunction</code></td><td>将函数注入到 <code>window</code> 对象上</td></tr><tr><td><code>page.queryObjects</code></td><td>获取所有属于这个类的对象，可以传递使用</td></tr></tbody></table><h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h4><table class="table"><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>page.goto</code></td><td>跳转页面</td></tr><tr><td><code>page.close</code></td><td>关闭</td></tr><tr><td><code>page.goBack</code></td><td>后退</td></tr><tr><td><code>page.goForward</code></td><td>前进</td></tr><tr><td><code>page.reload</code></td><td>刷新</td></tr><tr><td><code>page.setDefaultNavigationTimeout</code></td><td>设置页面跳转的超时时长</td></tr></tbody></table><h4 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h4><table class="table"><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>page.screenshot</code></td><td>截屏</td></tr><tr><td><code>page.pdf</code></td><td>生成 pdf</td></tr><tr><td><code>page.content</code></td><td>获取整个页面内容</td></tr><tr><td><code>page.title</code></td><td>获取页面 title</td></tr><tr><td><code>page.url</code></td><td>获取页面 url</td></tr><tr><td><code>page.viewport</code></td><td>获取页面 viewport</td></tr><tr><td><code>page.cookies</code></td><td>获取 cookies</td></tr></tbody></table><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><table class="table"><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td><code>page.on(&#39;console&#39;)</code></td><td>监听 <code>console.log</code> 等的调用</td></tr><tr><td><code>page.on(&#39;dialog&#39;)</code></td><td>监听页面的 <code>alert</code>, <code>beforeunload</code>, <code>confirm</code> 和 <code>prompt</code> 弹窗</td></tr><tr><td><code>page.on(&#39;load&#39;)</code></td><td>监听页面的加载</td></tr><tr><td><code>page.on(&#39;domcontentloaded&#39;)</code></td><td>监听页面 dom 加载完成</td></tr><tr><td><code>page.on(&#39;pageerror&#39;)</code></td><td>监听页面错误</td></tr><tr><td><code>page.on(&#39;request&#39;)</code></td><td>监听页面发送的请求</td></tr><tr><td><code>page.on(&#39;requestfailed&#39;)</code></td><td>监听失败的请求</td></tr><tr><td><code>page.on(&#39;requestfinished&#39;)</code></td><td>监听完成的请求</td></tr><tr><td><code>page.on(&#39;response&#39;)</code></td><td>监听页面接受到的响应</td></tr></tbody></table><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>通过一些命名空间可以快速访问到该页面下的其他实例。</p><table class="table"><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><code>page.keyboard</code></td><td>访问到页面的 Keyboard 对象</td></tr><tr><td><code>page.mouse</code></td><td>访问到页面的 Mouse 对象</td></tr><tr><td><code>page.touchscreen</code></td><td>访问到页面的 TouchScreen 对象</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://pptr.dev/" target="_blank" rel="external">Puppeteer 文档</a></li><li><a href="https://peter.sh/experiments/chromium-command-line-switches/" target="_blank" rel="external">Chromium CLI 参数</a></li><li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/DeviceDescriptors.js" target="_blank" rel="external">预设的 EmulateOptions</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Puppeteer 是 Google Chrome 出品的一个无头浏览器。如果你听说过 Phantomjs 或者 Selenium，那么就应该知道它是做什么的了。Puppeteer 与它们类似，提供了一系列 api，通过 DevTools 协议控制 Chromium/Chr
      
    
    </summary>
    
      <category term="Programmer" scheme="http://blog.xcatliu.com/categories/Programmer/"/>
    
    
      <category term="JavaScript" scheme="http://blog.xcatliu.com/tags/JavaScript/"/>
    
      <category term="Puppeteer" scheme="http://blog.xcatliu.com/tags/Puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>How to Get Changelist in Git Push Hook</title>
    <link href="http://blog.xcatliu.com/2017/09/26/how-to-get-changelist-in-git-push-hook/"/>
    <id>http://blog.xcatliu.com/2017/09/26/how-to-get-changelist-in-git-push-hook/</id>
    <published>2017-09-26T00:39:25.000Z</published>
    <updated>2017-09-26T00:47:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git hooks is a useful tool to run scripts before or after events. We usually use it to check the format of commit message, lint our code, prevent pushing code to master branch, or run test scripts before pushing.</p><p>Sometimes we need to get the changelist in pre-push hook. It may not be as easy as you think – It’s hard to know how many commits you have been submitted since you last checking out to the new branch.</p><p>After some investigation, I’ve found a way to get the diff file list between the current <code>HEAD</code> and <code>origin/master</code>:</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Find the common ancestor of current hash and origin/master</span><span class="token comment" spellcheck="true"># https://stackoverflow.com/questions/1549146/find-common-ancestor-of-two-git-branches</span><span class="token comment" spellcheck="true"># Command inside `` will be executed and pass to the variable</span>common_ancestor<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">git</span> merge-base HEAD origin/master<span class="token variable">`</span></span><span class="token comment" spellcheck="true"># --diff-filter=ACMRT Only show files which is appended, copied, modified, renamed or type-changed</span>changelist<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">git</span> <span class="token function">diff</span> $common_ancestor HEAD --name-only --diff-filter<span class="token operator">=</span>ACMRT<span class="token variable">`</span></span></code></pre><p>Posted to <a href="https://gist.github.com/xcatliu/ddc2aec4e4cde0824429477f7ea233cd" target="_blank" rel="external">gist</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git hooks is a useful tool to run scripts before or after events. We usually use it to check the format of commit message, lint our code,
      
    
    </summary>
    
      <category term="Programmer" scheme="http://blog.xcatliu.com/categories/Programmer/"/>
    
    
      <category term="Git" scheme="http://blog.xcatliu.com/tags/Git/"/>
    
      <category term="Git Hooks" scheme="http://blog.xcatliu.com/tags/Git-Hooks/"/>
    
      <category term="en" scheme="http://blog.xcatliu.com/tags/en/"/>
    
  </entry>
  
  <entry>
    <title>运行一个脚本，看看你的项目的代码质量吧</title>
    <link href="http://blog.xcatliu.com/2017/09/20/cqc/"/>
    <id>http://blog.xcatliu.com/2017/09/20/cqc/</id>
    <published>2017-09-19T16:00:00.000Z</published>
    <updated>2017-09-26T00:39:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>发表在 V2EX 上：<a href="https://www.v2ex.com/t/392337" target="_blank" rel="external">https://www.v2ex.com/t/392337</a></p></blockquote><ul><li>GitHub: <a href="https://github.com/xcatliu/cqc" target="_blank" rel="external">https://github.com/xcatliu/cqc</a></li></ul><p>代码质量有很多指标：</p><ol><li>源代码行数</li><li>代码重复率</li><li>圈复杂度</li><li>报错量（ Bug 数）占比</li><li>测试覆盖率</li><li>开发约束（代码块行数等）</li></ol><p>我做了一个脚本可以测出上面的 1, 2, 3</p><p>大家都来试一试吧！</p><h2 id="Supported-Languages"><a href="#Supported-Languages" class="headerlink" title="Supported Languages"></a>Supported Languages</h2><ul><li>js, jsx</li><li>css, less, scss, sass, styl</li></ul><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g cqc</code></pre><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><pre class=" language-bash"><code class="language-bash">cqc src/**/*.js src/**/*.jsx</code></pre><p>Output:</p><pre><code>Number of files:        9Source lines of code:   463Duplicate rate:         15.71%High complexity rate:   11.11%Max complexity:         19</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;发表在 V2EX 上：&lt;a href=&quot;https://www.v2ex.com/t/392337&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.v2ex.com/t/392337&lt;/a&gt;&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="Programmer" scheme="http://blog.xcatliu.com/categories/Programmer/"/>
    
    
      <category term="V2EX" scheme="http://blog.xcatliu.com/tags/V2EX/"/>
    
      <category term="Quality" scheme="http://blog.xcatliu.com/tags/Quality/"/>
    
      <category term="Complexity" scheme="http://blog.xcatliu.com/tags/Complexity/"/>
    
  </entry>
  
</feed>
